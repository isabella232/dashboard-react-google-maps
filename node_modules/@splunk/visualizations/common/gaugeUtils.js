/*!
 * Copyright © 2018 Splunk Inc.
 * SPLUNK CONFIDENTIAL – Use or disclosure of this material in whole or
 * in part without a valid written license from Splunk Inc. is PROHIBITED.
 */
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 59);
/******/ })
/************************************************************************/
/******/ ({

/***/ 15:
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/toConsumableArray");

/***/ }),

/***/ 22:
/***/ (function(module, exports) {

module.exports = require("@splunk/visualizations-shared/colorConstants");

/***/ }),

/***/ 30:
/***/ (function(module, exports) {

module.exports = require("lodash/uniqBy");

/***/ }),

/***/ 4:
/***/ (function(module, exports) {

module.exports = require("@splunk/ui-utils/i18n");

/***/ }),

/***/ 59:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GAUGE_THICKNESS", function() { return GAUGE_THICKNESS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILL_THICKNESS", function() { return FILL_THICKNESS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeWidth", function() { return getGaugeWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeHeight", function() { return getGaugeHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeLength", function() { return getGaugeLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeStartPosition", function() { return getGaugeStartPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeDimensions", function() { return getGaugeDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignGaugeColor", function() { return assignGaugeColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeBarLength", function() { return getGaugeBarLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeBarStartPositions", function() { return getGaugeBarStartPositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeBarWidth", function() { return getGaugeBarWidth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeBarHeight", function() { return getGaugeBarHeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFillBarDimensions", function() { return getFillBarDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFillerGaugeValueMarkerPositions", function() { return getFillerGaugeValueMarkerPositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMarkerBarDimensions", function() { return getMarkerBarDimensions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMarkerGaugeValueMarkerPositions", function() { return getMarkerGaugeValueMarkerPositions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSortedRanges", function() { return getSortedRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateRanges", function() { return validateRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGaugeRange", function() { return getGaugeRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradientStopOffsets", function() { return getGradientStopOffsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradientStopColors", function() { return getGradientStopColors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradientStops", function() { return getGradientStops; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGradientDimensions", function() { return getGradientDimensions; });
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_uniqBy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30);
/* harmony import */ var lodash_uniqBy__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_uniqBy__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(22);
/* harmony import */ var _splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__);




var GAUGE_THICKNESS = 50;
var FILL_THICKNESS = 38;
var GRADIENT_STOP_OFFSET_MIN = 0;
var GRADIENT_STOP_OFFSET_MAX = 100;
/**
 * get width for the whole gauge viz for horizontal or vertical view
 * @method getGaugeWidth
 * @param {Object} input
 * @param {Number} containerWidth
 * @param {String} orientation
 * @return {Number} width
 */

var getGaugeWidth = function getGaugeWidth(_ref) {
  var containerWidth = _ref.containerWidth,
      orientation = _ref.orientation;
  return orientation === 'vertical' ? GAUGE_THICKNESS : containerWidth * 0.8;
};
/**
 * get height for the whole gauge viz for horizontal or vertical view
 * @method getGaugeHeight
 * @param {Object} input
 * @param {Number} containerHeight
 * @param {String} orientation
 * @return {Number} height
 */

var getGaugeHeight = function getGaugeHeight(_ref2) {
  var containerHeight = _ref2.containerHeight,
      orientation = _ref2.orientation;
  return orientation === 'vertical' ? containerHeight * 0.8 : GAUGE_THICKNESS;
};
/**
 * get how long the gauge shoud be.
 * In horizontal view, gauge length equals to gauge width. In vertical view, it equals to gauge height.
 * @method getGaugeLength
 * @param {Object} input
 * @param {Number} input.containerWidth
 * @param {Number} input.containerHeight
 * @param {String} input.orientation
 * @return {Number} gaugeLength
 */

var getGaugeLength = function getGaugeLength(_ref3) {
  var containerWidth = _ref3.containerWidth,
      containerHeight = _ref3.containerHeight,
      orientation = _ref3.orientation;
  return orientation === 'vertical' ? getGaugeHeight({
    containerHeight: containerHeight,
    orientation: orientation
  }) : getGaugeWidth({
    containerWidth: containerWidth,
    orientation: orientation
  });
};
/**
 * get start x and y for rendering gauge
 * @method getGaugeStartPosition
 * @param {Object} input
 * @param {Number} containerWidth
 * @param {Number} containerHeight
 * @param {Number} gaugeLength
 * @param {String} orientation
 * @return {Object} position
 * @return {Number} position.gaugeStartX
 * @return {Number} position.gaugeStartY
 */

var getGaugeStartPosition = function getGaugeStartPosition(_ref4) {
  var containerWidth = _ref4.containerWidth,
      containerHeight = _ref4.containerHeight,
      gaugeLength = _ref4.gaugeLength,
      orientation = _ref4.orientation; // for horizontal view

  var gaugeStartX = (containerWidth - gaugeLength) / 2.0;
  var gaugeStartY = (containerHeight - GAUGE_THICKNESS) / 2.0;

  if (orientation === 'vertical') {
    gaugeStartX = (containerWidth - GAUGE_THICKNESS) / 2.0;
    gaugeStartY = (containerHeight - gaugeLength) / 2.0;
  }

  return {
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY
  };
};
/**
 * get dimensions for the whole gauge viz,
 * which can be useful to calculate background bar and major ticks positions.
 * @method getGaugeDimensions
 * @param {Object} input
 * @param {Number} input.containerWidth
 * @param {Number} input.containerHeight
 * @param {String} input.orientation  'horizontal' or 'vertical'
 * @return {Object} gaugeDimensions
 * @return {Number} gaugeDimensions.gaugeLength  how long the gauge shoud be in horizontal or vertical orientation.
 * @return {Number} gaugeDimensions.gaugeStartX  start x to render gauge
 * @return {Number} gaugeDimensions.gaugeStartY  start y to render gauge
 * @return {Number} gaugeDimensions.gaugeWidth   natural width of gauge
 * @return {Number} gaugeDimensions.gaugeHeight  natural height of gauge
 */

var getGaugeDimensions = function getGaugeDimensions(_ref5) {
  var containerWidth = _ref5.containerWidth,
      containerHeight = _ref5.containerHeight,
      orientation = _ref5.orientation;
  var gaugeLength = getGaugeLength({
    containerWidth: containerWidth,
    containerHeight: containerHeight,
    orientation: orientation
  });

  var _getGaugeStartPositio = getGaugeStartPosition({
    containerWidth: containerWidth,
    containerHeight: containerHeight,
    gaugeLength: gaugeLength,
    orientation: orientation
  }),
      gaugeStartX = _getGaugeStartPositio.gaugeStartX,
      gaugeStartY = _getGaugeStartPositio.gaugeStartY;

  var gaugeWidth = getGaugeWidth({
    containerWidth: containerWidth,
    orientation: orientation
  });
  var gaugeHeight = getGaugeHeight({
    containerHeight: containerHeight,
    orientation: orientation
  });
  return {
    gaugeLength: gaugeLength,
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight
  };
};
/**
 * if gaugeColor is not specified, auto assign a gauge color to the fill bar
 * based on how much percentage the value is taken between min and max
 * @method assignGaugeColor
 * @params
 * */

var assignGaugeColor = function assignGaugeColor(_ref6) {
  var value = _ref6.value,
      min = _ref6.min,
      max = _ref6.max;
  var rate = (value - min) / (max - min);

  if (rate <= 0.3) {
    return _splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2__["SEMANTIC_SUCCESS"];
  }

  if (rate > 0.3 && rate <= 0.6) {
    return _splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2__["SEMANTIC_WARNING"];
  }

  return _splunk_visualizations_shared_colorConstants__WEBPACK_IMPORTED_MODULE_2__["SEMANTIC_ERROR"];
};
/**
 * get inner bar length in gauge
 * @method getGaugeBarLength
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.value
 * @param {Number} input.min
 * @param {Number} input.max
 * @return {Number} gaugeBarLength
 */

var getGaugeBarLength = function getGaugeBarLength(_ref7) {
  var gaugeLength = _ref7.gaugeLength,
      value = _ref7.value,
      min = _ref7.min,
      max = _ref7.max;

  if (max < min) {
    return null;
  }

  if (value >= max) {
    return gaugeLength;
  }

  if (value < min) {
    return 0;
  }

  return gaugeLength * (value - min) / (max - min);
};
/**
 * get x and y position for rendering inner bar in gauge
 * @method getGaugeBarStartPositions
 * @param {Object} input
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth
 * @param {Number} input.gaugeHeight
 * @param {Number} input.gaugeBarLength
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.gaugeBarX
 * @return {Number} position.gaugeBarY
 */

var getGaugeBarStartPositions = function getGaugeBarStartPositions(_ref8) {
  var gaugeStartX = _ref8.gaugeStartX,
      gaugeStartY = _ref8.gaugeStartY,
      gaugeWidth = _ref8.gaugeWidth,
      gaugeHeight = _ref8.gaugeHeight,
      gaugeBarLength = _ref8.gaugeBarLength,
      orientation = _ref8.orientation;
  var gaugeBarX = gaugeStartX;
  var gaugeBarY = gaugeStartY;

  if (orientation === 'vertical') {
    gaugeBarX += (gaugeWidth - FILL_THICKNESS) / 2;
    gaugeBarY += gaugeHeight - gaugeBarLength;
  } else {
    gaugeBarY += (gaugeHeight - FILL_THICKNESS) / 2;
  }

  return {
    gaugeBarX: gaugeBarX,
    gaugeBarY: gaugeBarY
  };
};
/**
 * get width of inner bar in gauge
 * @method getGaugeBarWidth
 * @param {Object} input
 * @param {Number} input.gaugeBarLength
 * @param {String} orientation
 * @return {Number} gaugeBarWidth
 */

var getGaugeBarWidth = function getGaugeBarWidth(_ref9) {
  var gaugeBarLength = _ref9.gaugeBarLength,
      orientation = _ref9.orientation;
  return orientation === 'vertical' ? FILL_THICKNESS : gaugeBarLength;
};
/**
 * get height of inner bar in gauge
 * @method getGaugeBarWidth
 * @param {Object} input
 * @param {Number} input.gaugeBarLength
 * @param {String} orientation
 * @return {Number} gaugeBarHeight
 */

var getGaugeBarHeight = function getGaugeBarHeight(_ref10) {
  var gaugeBarLength = _ref10.gaugeBarLength,
      orientation = _ref10.orientation;
  return orientation === 'vertical' ? gaugeBarLength : FILL_THICKNESS;
};
/**
 * get dimensions for the fill bar in the gauge
 * @method getFillBarDimensions
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth,
 * @param {Number} input.gaugeHeight,
 * @param {Number} input.value,
 * @param {Number} input.min,
 * @param {Number} input.max,
 * @param {String} input.orientation
 * @return {Object} fillBarDimensions
 * @return {Number} fillBarDimensions.fillBarLength
 * @return {Number} fillBarDimensions.fillBarX
 * @return {Number} fillBarDimensions.fillBarY
 * @return {Number} fillBarDimensions.fillBarWidth
 * @return {Number} fillBarDimensions.fillBarHeight
 */

var getFillBarDimensions = function getFillBarDimensions(_ref11) {
  var gaugeLength = _ref11.gaugeLength,
      gaugeStartX = _ref11.gaugeStartX,
      gaugeStartY = _ref11.gaugeStartY,
      gaugeWidth = _ref11.gaugeWidth,
      gaugeHeight = _ref11.gaugeHeight,
      value = _ref11.value,
      min = _ref11.min,
      max = _ref11.max,
      orientation = _ref11.orientation;
  var gaugeBarLength = getGaugeBarLength({
    gaugeLength: gaugeLength,
    value: value,
    max: max,
    min: min
  });

  var _getGaugeBarStartPosi = getGaugeBarStartPositions({
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight,
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  }),
      fillBarX = _getGaugeBarStartPosi.gaugeBarX,
      fillBarY = _getGaugeBarStartPosi.gaugeBarY;

  var fillBarWidth = getGaugeBarWidth({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  var fillBarHeight = getGaugeBarHeight({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  return {
    fillBarLength: gaugeBarLength,
    fillBarX: fillBarX,
    fillBarY: fillBarY,
    fillBarWidth: fillBarWidth,
    fillBarHeight: fillBarHeight
  };
};
/**
 * get position x and y for value marker in filler gauge
 * @method getFillerGaugeValueMarkerPositions
 * @param {Object} input
 * @param {Number} input.fillBarX
 * @param {Number} input.fillBarY
 * @param {Number} input.fillBarLength
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.valueMarkerX
 * @return {Number} position.valueMarkerY
 */

var getFillerGaugeValueMarkerPositions = function getFillerGaugeValueMarkerPositions(_ref12) {
  var fillBarX = _ref12.fillBarX,
      fillBarY = _ref12.fillBarY,
      fillBarLength = _ref12.fillBarLength,
      orientation = _ref12.orientation;
  var valueMarkerX = fillBarX;
  var valueMarkerY = fillBarY;

  if (orientation === 'vertical') {
    valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;
  } else {
    valueMarkerX += fillBarLength;
    valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;
  }

  return {
    valueMarkerX: valueMarkerX,
    valueMarkerY: valueMarkerY
  };
};
/**
 * get dimensions for the marker bar in the gauge
 * @method getMarkerBarDimensions
 * @param {Object} input
 * @param {Number} input.gaugeLength
 * @param {Number} input.gaugeStartX
 * @param {Number} input.gaugeStartY
 * @param {Number} input.gaugeWidth,
 * @param {Number} input.gaugeHeight,
 * @param {String} input.orientation
 * @return {Object} markerBarDimensions
 * @return {Number} markerBarDimensions.markerBarLength
 * @return {Number} markerBarDimensions.markerBarX
 * @return {Number} markerBarDimensions.markerBarY
 * @return {Number} markerBarDimensions.markerBarWidth
 * @return {Number} markerBarDimensions.markerBarHeight
 */

var getMarkerBarDimensions = function getMarkerBarDimensions(_ref13) {
  var gaugeLength = _ref13.gaugeLength,
      gaugeStartX = _ref13.gaugeStartX,
      gaugeStartY = _ref13.gaugeStartY,
      gaugeWidth = _ref13.gaugeWidth,
      gaugeHeight = _ref13.gaugeHeight,
      orientation = _ref13.orientation;
  var gaugeBarLength = gaugeLength; // For marker gauge, inner marker bar spans the entire gauge

  var _getGaugeBarStartPosi2 = getGaugeBarStartPositions({
    gaugeStartX: gaugeStartX,
    gaugeStartY: gaugeStartY,
    gaugeWidth: gaugeWidth,
    gaugeHeight: gaugeHeight,
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  }),
      markerBarX = _getGaugeBarStartPosi2.gaugeBarX,
      markerBarY = _getGaugeBarStartPosi2.gaugeBarY;

  var markerBarWidth = getGaugeBarWidth({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  var markerBarHeight = getGaugeBarHeight({
    gaugeBarLength: gaugeBarLength,
    orientation: orientation
  });
  return {
    markerBarLength: gaugeBarLength,
    markerBarX: markerBarX,
    markerBarY: markerBarY,
    markerBarWidth: markerBarWidth,
    markerBarHeight: markerBarHeight
  };
};
/**
 * get position x and y for value marker in marker gauge
 * @method getMarkerGaugeValueMarkerPositions
 * @param {Object} input
 * @param {Number} input.markerBarX
 * @param {Number} input.markerBarY
 * @param {Number} input.markerBarHeight
 * @param {Number} input.markerBarLength
 * @param {Number} input.value
 * @param {Number} input.min
 * @param {Number} input.max
 * @param {String} input.orientation
 * @return {Object} position
 * @return {Number} position.valueMarkerX
 * @return {Number} position.valueMarkerY
 */

var getMarkerGaugeValueMarkerPositions = function getMarkerGaugeValueMarkerPositions(_ref14) {
  var markerBarX = _ref14.markerBarX,
      markerBarY = _ref14.markerBarY,
      markerBarHeight = _ref14.markerBarHeight,
      gaugeLength = _ref14.markerBarLength,
      orientation = _ref14.orientation,
      value = _ref14.value,
      min = _ref14.min,
      max = _ref14.max;
  var valueMarkerX = markerBarX;
  var valueMarkerY = markerBarY;

  if (orientation === 'vertical') {
    valueMarkerY += markerBarHeight - getGaugeBarLength({
      gaugeLength: gaugeLength,
      value: value,
      max: max,
      min: min
    });
    valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;
  } else {
    valueMarkerX += getGaugeBarLength({
      gaugeLength: gaugeLength,
      value: value,
      max: max,
      min: min
    });
    valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;
  }

  return {
    valueMarkerX: valueMarkerX,
    valueMarkerY: valueMarkerY
  };
};
/**
 * sort the ranges in ascending order
 * @method getSortedRanges
 * @param {Array} ranges
 * @return {Array} sortedRanges
 */

var getSortedRanges = function getSortedRanges(ranges) {
  return ranges.sort(function (a, b) {
    return a.from - b.from;
  });
};
/**
 * validate whether ranges prop is valid - continuous ranges, range.to < range.from, range.from != range.to
 * @method validateRanges
 * @param {Array} ranges
 * @return {String} error
 */

var validateRanges = function validateRanges(ranges) {
  if (!ranges.length) {
    return Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__["_"])('Prop "ranges" is missing entries');
  } // check whether a range has "from" >= "to" eg: 10 - 10, 100 - 10, -20 - -10 are invalid


  if (ranges.some(function (range) {
    return range.from >= range.to;
  })) {
    return Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__["_"])('Prop "ranges" has invalid entries: invalid range');
  } // check whether ranges have duplicate "from/to" eg: 0 - 50, 25 - 50


  if (ranges.length !== lodash_uniqBy__WEBPACK_IMPORTED_MODULE_1___default()(ranges, 'to').length || ranges.length !== lodash_uniqBy__WEBPACK_IMPORTED_MODULE_1___default()(ranges, 'from').length) {
    return Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__["_"])('Prop "ranges" has invalid entries: duplicate values');
  }

  var sortedRanges = getSortedRanges(ranges); // check whether ranges are continuous eg: 0 - 10, 10 - 20, 20 - 30

  for (var i = 1; i < sortedRanges.length; i += 1) {
    if (sortedRanges[i].from !== sortedRanges[i - 1].to) {
      return Object(_splunk_ui_utils_i18n__WEBPACK_IMPORTED_MODULE_3__["_"])('Prop "ranges" has invalid entries: discontinuous ranges');
    }
  }

  return null;
};
/**
 * calculate min and max value of gauge
 * @method getGaugeRange
 * @param {Array} ranges
 * @return {Object} gaugeRange
 * @return {Number} gaugeRange.min
 * @return {Number} gaugeRange.max
 */

var getGaugeRange = function getGaugeRange(ranges) {
  var min = Math.min.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(ranges.map(function (range) {
    return range.from;
  })));
  var max = Math.max.apply(Math, _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_0___default()(ranges.map(function (range) {
    return range.to;
  })));
  return {
    min: min,
    max: max
  };
};
/**
 * calculate stop offsets for linear gradient
 * @method getGradientStopOffsets
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} cumulativeOffsets
 */

var getGradientStopOffsets = function getGradientStopOffsets(_ref15) {
  var ranges = _ref15.ranges,
      orientation = _ref15.orientation;

  var _getGaugeRange = getGaugeRange(ranges),
      min = _getGaugeRange.min,
      max = _getGaugeRange.max;

  var offsetScale = (GRADIENT_STOP_OFFSET_MAX - GRADIENT_STOP_OFFSET_MIN) / (max - min);
  var offsets = ranges.map(function (range) {
    return Math.abs(range.from - range.to) * offsetScale;
  }); // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed

  offsets = orientation === 'vertical' ? offsets.reverse() : offsets;
  var cumulativeOffsets = [];
  offsets.reduce(function (accumulator, currentValue, idx) {
    cumulativeOffsets[idx] = accumulator + currentValue;
    return cumulativeOffsets[idx];
  }, 0);
  return cumulativeOffsets;
};
/**
 * calculate stop colors for linear gradient
 * @method getGradientStopColors
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} stopColors
 */

var getGradientStopColors = function getGradientStopColors(_ref16) {
  var ranges = _ref16.ranges,
      orientation = _ref16.orientation;
  var stopColors = ranges.map(function (range) {
    return range.value;
  }); // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed

  return orientation === 'vertical' ? stopColors.reverse() : stopColors;
};
/**
 * calculate linear gradient stops from ranges
 * @method getGradientStops
 * @param {Object} input
 * @param {Array} ranges
 * @param {String} orientation
 * @return {Array} stops
 */

var getGradientStops = function getGradientStops(_ref17) {
  var ranges = _ref17.ranges,
      orientation = _ref17.orientation;
  var stops = [];
  var offsets = getGradientStopOffsets({
    ranges: ranges,
    orientation: orientation
  });
  var stopColors = getGradientStopColors({
    ranges: ranges,
    orientation: orientation
  }); // Initialize stops with the first color stop

  stops.push({
    offset: "".concat(offsets[0], "%"),
    stopColor: stopColors[0]
  }); // Add the remaining color stops with gradient change at each stop

  for (var i = 1; i < ranges.length; i += 1) {
    stops.push({
      offset: "".concat(offsets[i - 1], "%"),
      stopColor: stopColors[i]
    });
    stops.push({
      offset: "".concat(offsets[i], "%"),
      stopColor: stopColors[i]
    });
  }

  return stops;
};
/**
 * calculate linear gradient dimensions
 * @method getGradientDimensions
 * @param {String} orientation
 * @return {Object} dimensions
 * @return {String} dimensions.x1
 * @return {String} dimensions.y1
 * @return {String} dimensions.x2
 * @return {String} dimensions.y2
 */

var getGradientDimensions = function getGradientDimensions(orientation) {
  var x1 = '0%';
  var y1 = '0%';
  var x2 = orientation === 'horizontal' ? '100%' : '0%';
  var y2 = orientation === 'horizontal' ? '0%' : '100%';
  return {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  };
};

/***/ })

/******/ });
//# sourceMappingURL=gaugeUtils.js.map