{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"@babel/runtime/helpers/toConsumableArray\"","webpack:///external \"@splunk/visualizations-shared/colorConstants\"","webpack:///external \"lodash/uniqBy\"","webpack:///external \"@splunk/ui-utils/i18n\"","webpack:///./src/common/gaugeUtils.js"],"names":["GAUGE_THICKNESS","FILL_THICKNESS","GRADIENT_STOP_OFFSET_MIN","GRADIENT_STOP_OFFSET_MAX","getGaugeWidth","containerWidth","orientation","getGaugeHeight","containerHeight","getGaugeLength","getGaugeStartPosition","gaugeLength","gaugeStartX","gaugeStartY","getGaugeDimensions","gaugeWidth","gaugeHeight","assignGaugeColor","value","min","max","rate","getGaugeBarLength","getGaugeBarStartPositions","gaugeBarLength","gaugeBarX","gaugeBarY","getGaugeBarWidth","getGaugeBarHeight","getFillBarDimensions","fillBarX","fillBarY","fillBarWidth","fillBarHeight","fillBarLength","getFillerGaugeValueMarkerPositions","valueMarkerX","valueMarkerY","getMarkerBarDimensions","markerBarX","markerBarY","markerBarWidth","markerBarHeight","markerBarLength","getMarkerGaugeValueMarkerPositions","getSortedRanges","a","b","validateRanges","ranges","_","range","uniqBy","sortedRanges","i","getGaugeRange","Math","getGradientStopOffsets","offsetScale","offsets","cumulativeOffsets","accumulator","getGradientStopColors","stopColors","getGradientStops","stops","offset","stopColor","getGradientDimensions","x1","y1","x2","y2"],"mappings":"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","file":"gaugeUtils.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 59);\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","module.exports = require(\"@splunk/visualizations-shared/colorConstants\");","module.exports = require(\"lodash/uniqBy\");","module.exports = require(\"@splunk/ui-utils/i18n\");","import uniqBy from 'lodash/uniqBy';\nimport {\n    SEMANTIC_SUCCESS,\n    SEMANTIC_WARNING,\n    SEMANTIC_ERROR,\n} from '@splunk/visualizations-shared/colorConstants';\nimport { _ } from '@splunk/ui-utils/i18n';\n\nexport const GAUGE_THICKNESS = 50;\nexport const FILL_THICKNESS = 38;\nconst GRADIENT_STOP_OFFSET_MIN = 0;\nconst GRADIENT_STOP_OFFSET_MAX = 100;\n\n/**\n * get width for the whole gauge viz for horizontal or vertical view\n * @method getGaugeWidth\n * @param {Object} input\n * @param {Number} containerWidth\n * @param {String} orientation\n * @return {Number} width\n */\nexport const getGaugeWidth = ({ containerWidth, orientation }) =>\n    orientation === 'vertical' ? GAUGE_THICKNESS : containerWidth * 0.8;\n\n/**\n * get height for the whole gauge viz for horizontal or vertical view\n * @method getGaugeHeight\n * @param {Object} input\n * @param {Number} containerHeight\n * @param {String} orientation\n * @return {Number} height\n */\nexport const getGaugeHeight = ({ containerHeight, orientation }) =>\n    orientation === 'vertical' ? containerHeight * 0.8 : GAUGE_THICKNESS;\n\n/**\n * get how long the gauge shoud be.\n * In horizontal view, gauge length equals to gauge width. In vertical view, it equals to gauge height.\n * @method getGaugeLength\n * @param {Object} input\n * @param {Number} input.containerWidth\n * @param {Number} input.containerHeight\n * @param {String} input.orientation\n * @return {Number} gaugeLength\n */\nexport const getGaugeLength = ({ containerWidth, containerHeight, orientation }) =>\n    orientation === 'vertical'\n        ? getGaugeHeight({ containerHeight, orientation })\n        : getGaugeWidth({ containerWidth, orientation });\n\n/**\n * get start x and y for rendering gauge\n * @method getGaugeStartPosition\n * @param {Object} input\n * @param {Number} containerWidth\n * @param {Number} containerHeight\n * @param {Number} gaugeLength\n * @param {String} orientation\n * @return {Object} position\n * @return {Number} position.gaugeStartX\n * @return {Number} position.gaugeStartY\n */\nexport const getGaugeStartPosition = ({ containerWidth, containerHeight, gaugeLength, orientation }) => {\n    // for horizontal view\n    let gaugeStartX = (containerWidth - gaugeLength) / 2.0;\n    let gaugeStartY = (containerHeight - GAUGE_THICKNESS) / 2.0;\n\n    if (orientation === 'vertical') {\n        gaugeStartX = (containerWidth - GAUGE_THICKNESS) / 2.0;\n        gaugeStartY = (containerHeight - gaugeLength) / 2.0;\n    }\n\n    return { gaugeStartX, gaugeStartY };\n};\n\n/**\n * get dimensions for the whole gauge viz,\n * which can be useful to calculate background bar and major ticks positions.\n * @method getGaugeDimensions\n * @param {Object} input\n * @param {Number} input.containerWidth\n * @param {Number} input.containerHeight\n * @param {String} input.orientation  'horizontal' or 'vertical'\n * @return {Object} gaugeDimensions\n * @return {Number} gaugeDimensions.gaugeLength  how long the gauge shoud be in horizontal or vertical orientation.\n * @return {Number} gaugeDimensions.gaugeStartX  start x to render gauge\n * @return {Number} gaugeDimensions.gaugeStartY  start y to render gauge\n * @return {Number} gaugeDimensions.gaugeWidth   natural width of gauge\n * @return {Number} gaugeDimensions.gaugeHeight  natural height of gauge\n */\nexport const getGaugeDimensions = ({ containerWidth, containerHeight, orientation }) => {\n    const gaugeLength = getGaugeLength({ containerWidth, containerHeight, orientation });\n    const { gaugeStartX, gaugeStartY } = getGaugeStartPosition({\n        containerWidth,\n        containerHeight,\n        gaugeLength,\n        orientation,\n    });\n    const gaugeWidth = getGaugeWidth({ containerWidth, orientation });\n    const gaugeHeight = getGaugeHeight({ containerHeight, orientation });\n\n    return {\n        gaugeLength,\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n    };\n};\n\n/**\n * if gaugeColor is not specified, auto assign a gauge color to the fill bar\n * based on how much percentage the value is taken between min and max\n * @method assignGaugeColor\n * @params\n * */\nexport const assignGaugeColor = ({ value, min, max }) => {\n    const rate = (value - min) / (max - min);\n\n    if (rate <= 0.3) {\n        return SEMANTIC_SUCCESS;\n    }\n    if (rate > 0.3 && rate <= 0.6) {\n        return SEMANTIC_WARNING;\n    }\n\n    return SEMANTIC_ERROR;\n};\n\n/**\n * get inner bar length in gauge\n * @method getGaugeBarLength\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.value\n * @param {Number} input.min\n * @param {Number} input.max\n * @return {Number} gaugeBarLength\n */\nexport const getGaugeBarLength = ({ gaugeLength, value, min, max }) => {\n    if (max < min) {\n        return null;\n    }\n\n    if (value >= max) {\n        return gaugeLength;\n    }\n\n    if (value < min) {\n        return 0;\n    }\n\n    return (gaugeLength * (value - min)) / (max - min);\n};\n\n/**\n * get x and y position for rendering inner bar in gauge\n * @method getGaugeBarStartPositions\n * @param {Object} input\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth\n * @param {Number} input.gaugeHeight\n * @param {Number} input.gaugeBarLength\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.gaugeBarX\n * @return {Number} position.gaugeBarY\n */\nexport const getGaugeBarStartPositions = ({\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    gaugeBarLength,\n    orientation,\n}) => {\n    let gaugeBarX = gaugeStartX;\n    let gaugeBarY = gaugeStartY;\n\n    if (orientation === 'vertical') {\n        gaugeBarX += (gaugeWidth - FILL_THICKNESS) / 2;\n        gaugeBarY += gaugeHeight - gaugeBarLength;\n    } else {\n        gaugeBarY += (gaugeHeight - FILL_THICKNESS) / 2;\n    }\n\n    return {\n        gaugeBarX,\n        gaugeBarY,\n    };\n};\n\n/**\n * get width of inner bar in gauge\n * @method getGaugeBarWidth\n * @param {Object} input\n * @param {Number} input.gaugeBarLength\n * @param {String} orientation\n * @return {Number} gaugeBarWidth\n */\nexport const getGaugeBarWidth = ({ gaugeBarLength, orientation }) =>\n    orientation === 'vertical' ? FILL_THICKNESS : gaugeBarLength;\n\n/**\n * get height of inner bar in gauge\n * @method getGaugeBarWidth\n * @param {Object} input\n * @param {Number} input.gaugeBarLength\n * @param {String} orientation\n * @return {Number} gaugeBarHeight\n */\nexport const getGaugeBarHeight = ({ gaugeBarLength, orientation }) =>\n    orientation === 'vertical' ? gaugeBarLength : FILL_THICKNESS;\n\n/**\n * get dimensions for the fill bar in the gauge\n * @method getFillBarDimensions\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth,\n * @param {Number} input.gaugeHeight,\n * @param {Number} input.value,\n * @param {Number} input.min,\n * @param {Number} input.max,\n * @param {String} input.orientation\n * @return {Object} fillBarDimensions\n * @return {Number} fillBarDimensions.fillBarLength\n * @return {Number} fillBarDimensions.fillBarX\n * @return {Number} fillBarDimensions.fillBarY\n * @return {Number} fillBarDimensions.fillBarWidth\n * @return {Number} fillBarDimensions.fillBarHeight\n */\nexport const getFillBarDimensions = ({\n    gaugeLength,\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    value,\n    min,\n    max,\n    orientation,\n}) => {\n    const gaugeBarLength = getGaugeBarLength({ gaugeLength, value, max, min });\n    const { gaugeBarX: fillBarX, gaugeBarY: fillBarY } = getGaugeBarStartPositions({\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n        gaugeBarLength,\n        orientation,\n    });\n    const fillBarWidth = getGaugeBarWidth({ gaugeBarLength, orientation });\n    const fillBarHeight = getGaugeBarHeight({ gaugeBarLength, orientation });\n\n    return {\n        fillBarLength: gaugeBarLength,\n        fillBarX,\n        fillBarY,\n        fillBarWidth,\n        fillBarHeight,\n    };\n};\n\n/**\n * get position x and y for value marker in filler gauge\n * @method getFillerGaugeValueMarkerPositions\n * @param {Object} input\n * @param {Number} input.fillBarX\n * @param {Number} input.fillBarY\n * @param {Number} input.fillBarLength\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.valueMarkerX\n * @return {Number} position.valueMarkerY\n */\nexport const getFillerGaugeValueMarkerPositions = ({ fillBarX, fillBarY, fillBarLength, orientation }) => {\n    let valueMarkerX = fillBarX;\n    let valueMarkerY = fillBarY;\n\n    if (orientation === 'vertical') {\n        valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    } else {\n        valueMarkerX += fillBarLength;\n        valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    }\n\n    return {\n        valueMarkerX,\n        valueMarkerY,\n    };\n};\n\n/**\n * get dimensions for the marker bar in the gauge\n * @method getMarkerBarDimensions\n * @param {Object} input\n * @param {Number} input.gaugeLength\n * @param {Number} input.gaugeStartX\n * @param {Number} input.gaugeStartY\n * @param {Number} input.gaugeWidth,\n * @param {Number} input.gaugeHeight,\n * @param {String} input.orientation\n * @return {Object} markerBarDimensions\n * @return {Number} markerBarDimensions.markerBarLength\n * @return {Number} markerBarDimensions.markerBarX\n * @return {Number} markerBarDimensions.markerBarY\n * @return {Number} markerBarDimensions.markerBarWidth\n * @return {Number} markerBarDimensions.markerBarHeight\n */\nexport const getMarkerBarDimensions = ({\n    gaugeLength,\n    gaugeStartX,\n    gaugeStartY,\n    gaugeWidth,\n    gaugeHeight,\n    orientation,\n}) => {\n    const gaugeBarLength = gaugeLength; // For marker gauge, inner marker bar spans the entire gauge\n    const { gaugeBarX: markerBarX, gaugeBarY: markerBarY } = getGaugeBarStartPositions({\n        gaugeStartX,\n        gaugeStartY,\n        gaugeWidth,\n        gaugeHeight,\n        gaugeBarLength,\n        orientation,\n    });\n    const markerBarWidth = getGaugeBarWidth({ gaugeBarLength, orientation });\n    const markerBarHeight = getGaugeBarHeight({ gaugeBarLength, orientation });\n\n    return {\n        markerBarLength: gaugeBarLength,\n        markerBarX,\n        markerBarY,\n        markerBarWidth,\n        markerBarHeight,\n    };\n};\n\n/**\n * get position x and y for value marker in marker gauge\n * @method getMarkerGaugeValueMarkerPositions\n * @param {Object} input\n * @param {Number} input.markerBarX\n * @param {Number} input.markerBarY\n * @param {Number} input.markerBarHeight\n * @param {Number} input.markerBarLength\n * @param {Number} input.value\n * @param {Number} input.min\n * @param {Number} input.max\n * @param {String} input.orientation\n * @return {Object} position\n * @return {Number} position.valueMarkerX\n * @return {Number} position.valueMarkerY\n */\nexport const getMarkerGaugeValueMarkerPositions = ({\n    markerBarX,\n    markerBarY,\n    markerBarHeight,\n    markerBarLength: gaugeLength,\n    orientation,\n    value,\n    min,\n    max,\n}) => {\n    let valueMarkerX = markerBarX;\n    let valueMarkerY = markerBarY;\n    if (orientation === 'vertical') {\n        valueMarkerY += markerBarHeight - getGaugeBarLength({ gaugeLength, value, max, min });\n        valueMarkerX -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    } else {\n        valueMarkerX += getGaugeBarLength({ gaugeLength, value, max, min });\n        valueMarkerY -= (GAUGE_THICKNESS - FILL_THICKNESS) / 4;\n    }\n\n    return {\n        valueMarkerX,\n        valueMarkerY,\n    };\n};\n\n/**\n * sort the ranges in ascending order\n * @method getSortedRanges\n * @param {Array} ranges\n * @return {Array} sortedRanges\n */\nexport const getSortedRanges = ranges => ranges.sort((a, b) => a.from - b.from);\n\n/**\n * validate whether ranges prop is valid - continuous ranges, range.to < range.from, range.from != range.to\n * @method validateRanges\n * @param {Array} ranges\n * @return {String} error\n */\nexport const validateRanges = ranges => {\n    if (!ranges.length) {\n        return _('Prop \"ranges\" is missing entries');\n    }\n\n    // check whether a range has \"from\" >= \"to\" eg: 10 - 10, 100 - 10, -20 - -10 are invalid\n    if (ranges.some(range => range.from >= range.to)) {\n        return _('Prop \"ranges\" has invalid entries: invalid range');\n    }\n\n    // check whether ranges have duplicate \"from/to\" eg: 0 - 50, 25 - 50\n    if (ranges.length !== uniqBy(ranges, 'to').length || ranges.length !== uniqBy(ranges, 'from').length) {\n        return _('Prop \"ranges\" has invalid entries: duplicate values');\n    }\n\n    const sortedRanges = getSortedRanges(ranges);\n\n    // check whether ranges are continuous eg: 0 - 10, 10 - 20, 20 - 30\n    for (let i = 1; i < sortedRanges.length; i += 1) {\n        if (sortedRanges[i].from !== sortedRanges[i - 1].to) {\n            return _('Prop \"ranges\" has invalid entries: discontinuous ranges');\n        }\n    }\n\n    return null;\n};\n\n/**\n * calculate min and max value of gauge\n * @method getGaugeRange\n * @param {Array} ranges\n * @return {Object} gaugeRange\n * @return {Number} gaugeRange.min\n * @return {Number} gaugeRange.max\n */\nexport const getGaugeRange = ranges => {\n    const min = Math.min(...ranges.map(range => range.from));\n    const max = Math.max(...ranges.map(range => range.to));\n    return { min, max };\n};\n\n/**\n * calculate stop offsets for linear gradient\n * @method getGradientStopOffsets\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} cumulativeOffsets\n */\nexport const getGradientStopOffsets = ({ ranges, orientation }) => {\n    const { min, max } = getGaugeRange(ranges);\n    const offsetScale = (GRADIENT_STOP_OFFSET_MAX - GRADIENT_STOP_OFFSET_MIN) / (max - min);\n    let offsets = ranges.map(range => Math.abs(range.from - range.to) * offsetScale);\n    // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed\n    offsets = orientation === 'vertical' ? offsets.reverse() : offsets;\n    const cumulativeOffsets = [];\n    offsets.reduce((accumulator, currentValue, idx) => {\n        cumulativeOffsets[idx] = accumulator + currentValue;\n        return cumulativeOffsets[idx];\n    }, 0);\n    return cumulativeOffsets;\n};\n\n/**\n * calculate stop colors for linear gradient\n * @method getGradientStopColors\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} stopColors\n */\nexport const getGradientStopColors = ({ ranges, orientation }) => {\n    const stopColors = ranges.map(range => range.value);\n    // When orientation is vertical, since the gauge starts from bottom to top, linear gradient should be reversed\n    return orientation === 'vertical' ? stopColors.reverse() : stopColors;\n};\n\n/**\n * calculate linear gradient stops from ranges\n * @method getGradientStops\n * @param {Object} input\n * @param {Array} ranges\n * @param {String} orientation\n * @return {Array} stops\n */\nexport const getGradientStops = ({ ranges, orientation }) => {\n    const stops = [];\n    const offsets = getGradientStopOffsets({ ranges, orientation });\n    const stopColors = getGradientStopColors({ ranges, orientation });\n    // Initialize stops with the first color stop\n    stops.push({ offset: `${offsets[0]}%`, stopColor: stopColors[0] });\n    // Add the remaining color stops with gradient change at each stop\n    for (let i = 1; i < ranges.length; i += 1) {\n        stops.push({ offset: `${offsets[i - 1]}%`, stopColor: stopColors[i] });\n        stops.push({ offset: `${offsets[i]}%`, stopColor: stopColors[i] });\n    }\n    return stops;\n};\n\n/**\n * calculate linear gradient dimensions\n * @method getGradientDimensions\n * @param {String} orientation\n * @return {Object} dimensions\n * @return {String} dimensions.x1\n * @return {String} dimensions.y1\n * @return {String} dimensions.x2\n * @return {String} dimensions.y2\n */\nexport const getGradientDimensions = orientation => {\n    const x1 = '0%';\n    const y1 = '0%';\n    const x2 = orientation === 'horizontal' ? '100%' : '0%';\n    const y2 = orientation === 'horizontal' ? '0%' : '100%';\n    return { x1, y1, x2, y2 };\n};\n"],"sourceRoot":""}